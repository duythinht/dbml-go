package gen

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/duythinht/dbml-go/core"
	"github.com/duythinht/dbml-go/internal/gen-go-model/genutil"
)

const (
	GoTypeAnnotation    = "gotype"
	GoPointerAnnotation = "gopointer"
)

type generator struct {
	dbml             *core.DBML
	out              string
	gopackage        string
	fieldtags        []string
	types            map[string]jen.Code
	shouldGenTblName bool
}

func newgen() *generator {
	return &generator{
		types: make(map[string]jen.Code),
	}
}

func (g *generator) file() *jen.File {
	return jen.NewFilePathName(g.out, g.gopackage)
}

func (g *generator) generate() error {
	if err := g.genEnums(); err != nil {
		return err
	}
	return nil
}

func (g *generator) genEnums() error {
	for _, enum := range g.dbml.Enums {
		if err := g.genEnum(enum); err != nil {
			return err
		}
	}
	for _, table := range g.dbml.Tables {
		if err := g.genTable(table); err != nil {
			return err
		}
	}

	return nil
}

func (g *generator) genEnum(enum core.Enum) error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	enumOriginName := genutil.NormalizeTypeName(enum.Name)
	enumGoTypeName := genutil.NormalizeGoTypeName(enum.Name)

	f.PackageComment("Code generated by dbml-gen-go-model. DO NOT EDIT.")
	f.PackageComment("Supported by duythinht@2020")
	f.Commentf("%s is generated type for enum '%s'", enumGoTypeName, enumOriginName)
	f.Type().Id(enumGoTypeName).Int()

	f.Const().DefsFunc(func(group *jen.Group) {
		group.Id("_").Id(enumGoTypeName).Op("=").Iota()
		for _, value := range enum.Values {
			v := group.Id(genutil.NormalLizeGoName(value.Name))
			if value.Note != "" {
				v.Comment(value.Note)
			}
		}
	})

	g.types[enum.Name] = jen.Id(enumGoTypeName)

	return f.Save(fmt.Sprintf("%s/%s.enum.go", g.out, genutil.Normalize(enum.Name)))
}

func (g *generator) genTable(table core.Table) error {
	f := jen.NewFilePathName(g.out, g.gopackage)

	tableOriginName := genutil.Normalize(table.Name)
	tableGoTypeName := genutil.NormalizeGoTypeName(table.Name)

	f.PackageComment("Code generated by dbml-gen-go-model. DO NOT EDIT.")
	f.PackageComment("Supported by duythinht@2020")
	f.Commentf("%s is generated type for table '%s'", tableGoTypeName, tableOriginName)

	var genColumnErr error

	cols := make([]string, 0)

	f.Type().Id(tableGoTypeName).StructFunc(func(group *jen.Group) {
		for _, column := range table.Columns {
			columnName := genutil.NormalLizeGoName(column.Name)
			columnOriginName := genutil.Normalize(column.Name)
			t, ok := g.getJenType(column)
			if !ok {
				genColumnErr = fmt.Errorf("type '%s' is not support", column.Type)
			}
			if strings.ToLower(column.Annotations[GoPointerAnnotation]) == "true" {
				t = jen.Op("*").Add(t)
			}
			if column.Settings.Note != "" {
				group.Comment(column.Settings.Note)
			}

			gotags := make(map[string]string)
			for _, t := range g.fieldtags {
				gotags[strings.TrimSpace(t)] = columnOriginName
			}
			group.Id(columnName).Add(t).Tag(gotags)
			cols = append(cols, columnOriginName)
		}
	})

	if genColumnErr != nil {
		return genColumnErr
	}

	tableMetadataType := "__tbl_" + tableOriginName
	tableMetadataColumnsType := tableMetadataType + "_columns"

	f.Commentf("// table '%s' columns list struct", tableOriginName)
	f.Type().Id(tableMetadataColumnsType).StructFunc(func(group *jen.Group) {
		for _, column := range table.Columns {
			group.Id(genutil.NormalLizeGoName(column.Name)).String()
		}
	})

	f.Commentf("// table '%s' metadata struct", tableOriginName)
	f.Type().Id("__tbl_"+tableOriginName).Struct(
		jen.Id("Name").String(),
		jen.Id("Columns").Id(tableMetadataColumnsType),
	)

	tableMetadataVar := "_tbl_" + tableOriginName

	f.Commentf("// table '%s' metadata info", tableOriginName)
	f.Var().Id(tableMetadataVar).Op("=").Id(tableMetadataType).Values(jen.DictFunc(func(d jen.Dict) {
		d[jen.Id("Name")] = jen.Lit(tableOriginName)
		d[jen.Id("Columns")] = jen.Id(tableMetadataColumnsType).Values(jen.DictFunc(func(d jen.Dict) {
			for _, column := range table.Columns {
				columnName := genutil.NormalLizeGoName(column.Name)
				columnOriginName := genutil.Normalize(column.Name)
				d[jen.Id(columnName)] = jen.Lit(columnOriginName)
			}
		}))
	}))

	f.Commentf("GetColumns return list columns name for table '%s'", tableOriginName)
	f.Func().Params(
		jen.Op("*").Id(tableMetadataType),
	).Id("GetColumns").Params().Index().String().Block(
		jen.Return(jen.Index().String().ValuesFunc(func(g *jen.Group) {
			for _, col := range cols {
				g.Lit(col)
			}
		})),
	)

	f.Commentf("T return metadata info for table '%s'", tableOriginName)
	f.Func().Params(
		jen.Op("*").Id(tableGoTypeName),
	).Id("T").Params().Op("*").Id(tableMetadataType).Block(
		jen.Return().Op("&").Id(tableMetadataVar),
	)

	if g.shouldGenTblName {
		f.Commentf("TableName return table name")
		f.Func().Params(
			jen.Id(tableGoTypeName),
		).Id("TableName").Params().Id("string").Block(
			jen.Return(jen.Lit(tableOriginName)),
		)
	}

	return f.Save(fmt.Sprintf("%s/%s.table.go", g.out, genutil.Normalize(table.Name)))
}

const primeTypePattern = `^(\w+)(\(d+\))?`

var (
	regexType    = regexp.MustCompile(primeTypePattern)
	builtinTypes = map[string]jen.Code{
		"int":       jen.Int(),
		"int8":      jen.Int8(),
		"int16":     jen.Int16(),
		"int32":     jen.Int32(),
		"int64":     jen.Int64(),
		"bigint":    jen.Int64(),
		"uint":      jen.Uint(),
		"uint8":     jen.Uint8(),
		"uint16":    jen.Uint16(),
		"uint32":    jen.Uint32(),
		"uint64":    jen.Uint64(),
		"float":     jen.Float64(),
		"float32":   jen.Float32(),
		"float64":   jen.Float64(),
		"bool":      jen.Bool(),
		"text":      jen.String(),
		"varchar":   jen.String(),
		"char":      jen.String(),
		"byte":      jen.Byte(),
		"rune":      jen.Rune(),
		"timestamp": jen.Int(),
		"datetime":  jen.Qual("time", "Time"),
	}
)

func (g *generator) getJenType(col core.Column) (jen.Code, bool) {
	// generate from annotation
	t, ok := getJenTypeFromAnnotation(col.Annotations[GoTypeAnnotation])
	if ok {
		return t, ok
	}

	// generate from column type
	m := regexType.FindStringSubmatch(col.Type)
	if len(m) >= 2 {
		// lookup for builtin type
		if t, ok := builtinTypes[m[1]]; ok {
			return t, ok
		}
	}
	t, ok = g.types[col.Type]
	return t, ok
}

func getJenTypeFromAnnotation(s string) (jen.Code, bool) {
	if len(s) == 0 {
		return nil, false
	}

	parts := strings.Split(s, ":")
	if len(parts) >= 2 {
		return jen.Qual(parts[0], parts[1]), true
	}
	return jen.Id(parts[0]), true
}
